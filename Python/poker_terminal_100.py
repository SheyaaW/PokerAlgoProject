# -*- coding: utf-8 -*-
"""Poker_special_final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dsWBjmBbm-PlBhIyT06PbdcFv4-YFM5n

# Dealer
"""

from typing import Sequence

class Card:

    # Static class that handles cards. We represent cards as 32-bit integers, so
    # there is no object instantiation - they are just ints. Most of the bits are
    # used, and have a specific meaning. See below:

    #                                 Card:

    #                       bitrank     suit rank   prime
    #                 +--------+--------+--------+--------+
    #                 |xxxbbbbb|bbbbbbbb|cdhsrrrr|xxpppppp|
    #                 +--------+--------+--------+--------+

    #     1) p = prime number of rank (deuce=2,trey=3,four=5,...,ace=41)
    #     2) r = rank of card (deuce=0,trey=1,four=2,five=3,...,ace=12)
    #     3) cdhs = suit of card (bit turned on based on suit of card)
    #     4) b = bit turned on depending on rank of card
    #     5) x = unused

    # This representation will allow us to do very important things like:
    # - Make a unique prime prodcut for each hand
    # - Detect flushes
    # - Detect straights

    # and is also quite performant.

    #Define constant value
    # the basics
    STR_RANKS: str = '23456789TJQKA'
    STR_SUITS: str = 'shdc'
    INT_RANKS: range = range(13)
    PRIMES: list[int] = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41] #[2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A]

    # conversion from string => int
    CHAR_RANK_TO_INT_RANK: dict[str, int] = dict(zip(list(STR_RANKS), INT_RANKS))
    CHAR_SUIT_TO_INT_SUIT: dict[str, int] = {
        's': 1,  # spades
        'h': 2,  # hearts
        'd': 4,  # diamonds
        'c': 8,  # clubs
        '\u2660': 1, # spades (unicode) the spades symbol (♠)
        '\u2764': 2, # hearts (unicode) the heart symbol (❤)
        '\u2666': 4, # diamonds (unicode) the diamond symbol (♦)
        '\u2663': 8, # clubs (unicode) the clubs symbol (♣)
    }
    INT_SUIT_TO_CHAR_SUIT: str = 'xshxdxxxc'

    # for pretty printing
    PRETTY_SUITS: dict[int, str] = {
        1: chr(9824),   # spades
        2: chr(9829),   # hearts
        4: chr(9830),   # diamonds
        8: chr(9827)    # clubs
    }

    SUIT_COLORS: dict[int, str] = {
        2: "red",
        4: "blue",
        8: "green"
    }

    @staticmethod
    def new(string: str) -> int:
        # Converts Card string to binary integer representation of card, inspired by:

        # http://www.suffecool.net/poker/evaluator.html

        rank_char = string[0] #rank
        suit_char = string[1] #suit
        rank_int = Card.CHAR_RANK_TO_INT_RANK[rank_char] #get value from rank list
        suit_int = Card.CHAR_SUIT_TO_INT_SUIT[suit_char] #get value from suit list
        rank_prime = Card.PRIMES[rank_int] #get value(index) from primes list

        bitrank = 1 << rank_int << 16
        suit = suit_int << 12
        rank = rank_int << 8

        return bitrank | suit | rank | rank_prime

    @staticmethod
    def int_to_str(card_int: int) -> str:
        rank_int = Card.get_rank_int(card_int)
        suit_int = Card.get_suit_int(card_int)
        return Card.STR_RANKS[rank_int] + Card.INT_SUIT_TO_CHAR_SUIT[suit_int]

    @staticmethod
    def get_rank_int(card_int: int) -> int:
        return (card_int >> 8) & 0xF

    @staticmethod
    def get_suit_int(card_int: int) -> int:
        return (card_int >> 12) & 0xF

    @staticmethod
    def get_bitrank_int(card_int: int) -> int:
        return (card_int >> 16) & 0x1FFF

    @staticmethod
    def get_prime(card_int: int) -> int:
        return card_int & 0x3F

    @staticmethod
    def hand_to_binary(card_strs: Sequence[str]) -> list[int]:

        # Expects a list of cards as strings and returns a list
        # of integers of same length corresponding to those strings.

        bhand = []
        for c in card_strs:
            bhand.append(Card.new(c))
        return bhand

    @staticmethod
    def prime_product_from_hand(card_ints: Sequence[int]) -> int:

        # Expects a list of cards in integer form.


        product = 1
        for c in card_ints:
            product *= (c & 0xFF)

        return product

    @staticmethod
    def prime_product_from_rankbits(rankbits: int) -> int:
        # """
        # Returns the prime product using the bitrank (b)
        # bits of the hand. Each 1 in the sequence is converted
        # to the correct prime and multiplied in.

        # Params:
        #     rankbits = a single 32-bit (only 13-bits set) integer representing
        #             the ranks of 5 _different_ ranked cards
        #             (5 of 13 bits are set)

        # Primarily used for evaulating flushes and straights,
        # two occasions where we know the ranks are *ALL* different.

        # Assumes that the input is in form (set bits):

        #                       rankbits
        #                 +--------+--------+
        #                 |xxxbbbbb|bbbbbbbb|
        #                 +--------+--------+

        # """
        product = 1
        for i in Card.INT_RANKS:
            # if the ith bit is set
            if rankbits & (1 << i):
                product *= Card.PRIMES[i]

        return product

    @staticmethod
    def int_to_binary(card_int: int) -> str:
        # """
        # For debugging purposes. Displays the binary number as a
        # human readable string in groups of four digits.
        # """
        bstr = bin(card_int)[2:][::-1]  # chop off the 0b and THEN reverse string
        output = list("".join(["0000" + "\t"] * 7) + "0000")

        for i in range(len(bstr)):
            output[i + int(i/4)] = bstr[i]

        # output the string to console
        output.reverse()
        return "".join(output)

    @staticmethod
    def int_to_pretty_str(card_int: int) -> str:
        # """
        # Prints a single card
        # """

        color = False
        try:
            from termcolor import colored
            # for mac, linux: http://pypi.python.org/pypi/termcolor
            # can use for windows: http://pypi.python.org/pypi/colorama
            color = True
        except ImportError:
            pass

        # suit and rank
        suit_int = Card.get_suit_int(card_int)
        rank_int = Card.get_rank_int(card_int)

        # color
        s = Card.PRETTY_SUITS[suit_int]
        if color and suit_int in Card.SUIT_COLORS:
            s = colored(s, Card.SUIT_COLORS[suit_int])

        r = Card.STR_RANKS[rank_int]

        return "{}{}".format(r,s)

    @staticmethod
    def print_pretty_card(card_int: int) -> None:
        # """
        # Expects a single integer as input
        # """
        print(Card.int_to_pretty_str(card_int))

    @staticmethod
    def ints_to_pretty_str(card_ints: Sequence[int]) -> str:
        # """
        # Expects a list of cards in integer form.
        # """
        output = " "
        for i in range(len(card_ints)):
            c = card_ints[i]
            if i != len(card_ints) - 1:
                output += str(Card.int_to_pretty_str(c)) + ","
            else:
                output += str(Card.int_to_pretty_str(c)) + " "

        return output

    @staticmethod
    def print_pretty_cards(card_ints: Sequence[int]) -> list[str]:
        # """
        # Expects a list of cards in integer form.
        # """
        print(Card.ints_to_pretty_str(card_ints))
        return

from random import Random


class Deck:
    # """
    # Class representing a deck. The first time we create, we seed the static
    # deck with the list of unique card integers. Each object instantiated simply
    # makes a copy of this object and shuffles it.
    # """
    _FULL_DECK: list[int] = []

    def __init__(self, seed: int = None) -> None:
        self._random = Random(seed)
        self.shuffle()

    def shuffle(self) -> None:
        # and then shuffle
        self.cards = Deck.GetFullDeck()
        self._random.shuffle(self.cards)

    def draw(self, n: int = 1) -> list[int]:
        cards = []
        if n == 1:
          card = self.cards.pop()
          return card
        for _ in range(n):
            cards.append(self.cards.pop())
        return cards

    def __str__(self) -> str:
        return Card.ints_to_pretty_str(self.cards)

    @staticmethod
    def GetFullDeck() -> list[int]:
        if Deck._FULL_DECK:
            return list(Deck._FULL_DECK)

        # create the standard 52 card deck
        for rank in Card.STR_RANKS:
            for suit in Card.STR_SUITS:
                Deck._FULL_DECK.append(Card.new(rank + suit))

        return list(Deck._FULL_DECK)

"""# Evaluator"""

from collections.abc import Iterator
import itertools
from typing import Sequence

Card = Card()

class LookupTable:
    # """
    # Number of Distinct Hand Values:

    # Straight Flush   10
    # Four of a Kind   156      [(13 choose 2) * (2 choose 1)]
    # Full Houses      156      [(13 choose 2) * (2 choose 1)]
    # Flush            1277     [(13 choose 5) - 10 straight flushes]
    # Straight         10
    # Three of a Kind  858      [(13 choose 3) * (3 choose 1)]
    # Two Pair         858      [(13 choose 3) * (3 choose 2)]
    # One Pair         2860     [(13 choose 4) * (4 choose 1)]
    # High Card      + 1277     [(13 choose 5) - 10 straights]
    # -------------------------
    # TOTAL            7462

    # Here we create a lookup table which maps:
    #     5 card hand's unique prime product => rank in range [1, 7462]

    # Examples:
    # * Royal flush (best hand possible)          => 1
    # * 7-5-4-3-2 unsuited (worst hand possible)  => 7462
    # """
    MAX_ROYAL_FLUSH: int     = 1
    MAX_STRAIGHT_FLUSH: int  = 10
    MAX_FOUR_OF_A_KIND: int  = 166
    MAX_FULL_HOUSE: int      = 322
    MAX_FLUSH: int           = 1599
    MAX_STRAIGHT: int        = 1609
    MAX_THREE_OF_A_KIND: int = 2467
    MAX_TWO_PAIR: int        = 3325
    MAX_PAIR: int            = 6185
    MAX_HIGH_CARD: int       = 7462

    MAX_TO_RANK_CLASS: dict[int, int] = {
        MAX_ROYAL_FLUSH: 0,
        MAX_STRAIGHT_FLUSH: 1,
        MAX_FOUR_OF_A_KIND: 2,
        MAX_FULL_HOUSE: 3,
        MAX_FLUSH: 4,
        MAX_STRAIGHT: 5,
        MAX_THREE_OF_A_KIND: 6,
        MAX_TWO_PAIR: 7,
        MAX_PAIR: 8,
        MAX_HIGH_CARD: 9
    }

    RANK_CLASS_TO_STRING: dict[int, str] = {
        0: "Royal Flush",
        1: "Straight Flush",
        2: "Four of a Kind",
        3: "Full House",
        4: "Flush",
        5: "Straight",
        6: "Three of a Kind",
        7: "Two Pair",
        8: "Pair",
        9: "High Card"
    }

    def __init__(self) -> None:
        # """
        # Calculates lookup tables
        # """
        # create dictionaries
        self.flush_lookup: dict[int, int] = {}
        self.unsuited_lookup: dict[int, int] = {}

        # create the lookup table in piecewise fashion
        # this will call straights and high cards method,
        # we reuse some of the bit sequences
        self.flushes()
        self.multiples()

    def flushes(self) -> None:
        # """
        # Straight flushes and flushes.

        # Lookup is done on 13 bit integer (2^13 > 7462):
        # xxxbbbbb bbbbbbbb => integer hand index
        # """

        # straight flushes in rank order
        straight_flushes = [
            7936,  # int('0b1111100000000', 2), # royal flush
            3968,  # int('0b111110000000', 2),
            1984,  # int('0b11111000000', 2),
            992,   # int('0b1111100000', 2),
            496,   # int('0b111110000', 2),
            248,   # int('0b11111000', 2),
            124,   # int('0b1111100', 2),
            62,    # int('0b111110', 2),
            31,    # int('0b11111', 2),
            4111   # int('0b1000000001111', 2) # 5 high
        ]

        # now we'll dynamically generate all the other
        # flushes (including straight flushes)
        flushes = []
        gen = self.get_lexographically_next_bit_sequence(int('0b11111', 2))

        # 1277 = number of high cards
        # 1277 + len(str_flushes) is number of hands with all cards unique rank
        for i in range(1277 + len(straight_flushes) - 1):   # we also iterate over SFs
            # pull the next flush pattern from our generator
            f = next(gen)

            # if this flush matches perfectly any
            # straight flush, do not add it
            notSF = True
            for sf in straight_flushes:
                # if f XOR sf == 0, then bit pattern
                # is same, and we should not add
                if not f ^ sf:
                    notSF = False

            if notSF:
                flushes.append(f)

        # we started from the lowest straight pattern, now we want to start ranking from
        # the most powerful hands, so we reverse
        flushes.reverse()

        # now add to the lookup map:
        # start with straight flushes and the rank of 1
        # since it is the best hand in poker
        # rank 1 = Royal Flush!
        rank = 1
        for sf in straight_flushes:
            prime_product = Card.prime_product_from_rankbits(sf)
            self.flush_lookup[prime_product] = rank
            rank += 1

        # we start the counting for flushes on max full house, which
        # is the worst rank that a full house can have (2,2,2,3,3)
        rank = LookupTable.MAX_FULL_HOUSE + 1
        for f in flushes:
            prime_product = Card.prime_product_from_rankbits(f)
            self.flush_lookup[prime_product] = rank
            rank += 1

        # we can reuse these bit sequences for straights
        # and high cards since they are inherently related
        # and differ only by context
        self.straight_and_highcards(straight_flushes, flushes)

    def straight_and_highcards(self, straights: Sequence[int], highcards: Sequence[int]) -> None:
        # """
        # Unique five card sets. Straights and highcards.

        # Reuses bit sequences from flush calculations.
        # """
        rank = LookupTable.MAX_FLUSH + 1

        for s in straights:
            prime_product = Card.prime_product_from_rankbits(s)
            self.unsuited_lookup[prime_product] = rank
            rank += 1

        rank = LookupTable.MAX_PAIR + 1
        for h in highcards:
            prime_product = Card.prime_product_from_rankbits(h)
            self.unsuited_lookup[prime_product] = rank
            rank += 1

    def multiples(self) -> None:
        # """
        # Pair, Two Pair, Three of a Kind, Full House, and 4 of a Kind.
        # """
        backwards_ranks = list(range(len(Card.INT_RANKS) - 1, -1, -1))

        # 1) Four of a Kind
        rank = LookupTable.MAX_STRAIGHT_FLUSH + 1

        # for each choice of a set of four rank
        for i in backwards_ranks:

            # and for each possible kicker rank
            kickers = backwards_ranks[:]
            kickers.remove(i)
            for k in kickers:
                product = Card.PRIMES[i]**4 * Card.PRIMES[k]
                self.unsuited_lookup[product] = rank
                rank += 1

        # 2) Full House
        rank = LookupTable.MAX_FOUR_OF_A_KIND + 1

        # for each three of a kind
        for i in backwards_ranks:

            # and for each choice of pair rank
            pairranks = backwards_ranks[:]
            pairranks.remove(i)
            for pr in pairranks:
                product = Card.PRIMES[i]**3 * Card.PRIMES[pr]**2
                self.unsuited_lookup[product] = rank
                rank += 1

        # 3) Three of a Kind
        rank = LookupTable.MAX_STRAIGHT + 1

        # pick three of one rank
        for r in backwards_ranks:

            kickers = backwards_ranks[:]
            kickers.remove(r)
            gen = itertools.combinations(kickers, 2)

            for kickers_2combo in gen:

                c1, c2 = kickers_2combo
                product = Card.PRIMES[r]**3 * Card.PRIMES[c1] * Card.PRIMES[c2]
                self.unsuited_lookup[product] = rank
                rank += 1

        # 4) Two Pair
        rank = LookupTable.MAX_THREE_OF_A_KIND + 1

        tpgen = itertools.combinations(tuple(backwards_ranks), 2)
        for tp in tpgen:

            pair1, pair2 = tp
            kickers = backwards_ranks[:]
            kickers.remove(pair1)
            kickers.remove(pair2)
            for kicker in kickers:

                product = Card.PRIMES[pair1]**2 * Card.PRIMES[pair2]**2 * Card.PRIMES[kicker]
                self.unsuited_lookup[product] = rank
                rank += 1

        # 5) Pair
        rank = LookupTable.MAX_TWO_PAIR + 1

        # choose a pair
        for pairrank in backwards_ranks:

            kickers = backwards_ranks[:]
            kickers.remove(pairrank)
            kgen = itertools.combinations(tuple(kickers), 3)

            for kickers_3combo in kgen:

                k1, k2, k3 = kickers_3combo
                product = Card.PRIMES[pairrank]**2 * Card.PRIMES[k1] \
                    * Card.PRIMES[k2] * Card.PRIMES[k3]
                self.unsuited_lookup[product] = rank
                rank += 1

    def write_table_to_disk(self, table: dict[int, int], filepath: str) -> None:
        # """
        # Writes lookup table to disk
        # """
        with open(filepath, 'w') as f:
            for prime_prod, rank in table.items():
                f.write(str(prime_prod) + "," + str(rank) + '\n')

    def get_lexographically_next_bit_sequence(self, bits: int) -> Iterator[int]:
        # """
        # Bit hack from here:
        # http://www-graphics.stanford.edu/~seander/bithacks.html#NextBitPermutation

        # Generator even does this in poker order rank
        # so no need to sort when done! Perfect.
        # """
        t = int((bits | (bits - 1))) + 1
        next = t | ((int(((t & -t) / (bits & -bits))) >> 1) - 1)
        yield next
        while True:
            t = (next | (next - 1)) + 1
            next = t | ((((t & -t) // (next & -next)) >> 1) - 1)
            yield next

import itertools
from typing import Sequence



class Evaluator:
    # """
    # Evaluates hand strengths using a variant of Cactus Kev's algorithm:
    # http://suffe.cool/poker/evaluator.html

    # I make considerable optimizations in terms of speed and memory usage,
    # in fact the lookup table generation can be done in under a second and
    # consequent evaluations are very fast. Won't beat C, but very fast as
    # all calculations are done with bit arithmetic and table lookups.
    # """

    HAND_LENGTH = 2
    BOARD_LENGTH = 5

    def __init__(self) -> None:

        self.table = LookupTable()

        self.hand_size_map = {
            5: self._five,
            6: self._six,
            7: self._seven
        }

    def evaluate(self, hand: list[int], board: list[int]) -> int:
        # """
        # This is the function that the user calls to get a hand rank.

        # No input validation because that's cycles!
        # """
        all_cards = hand + board
        return self.hand_size_map[len(all_cards)](all_cards)

    def _five(self, cards: Sequence[int]) -> int:
        # """
        # Performs an evalution given cards in integer form, mapping them to
        # a rank in the range [1, 7462], with lower ranks being more powerful.

        # Variant of Cactus Kev's 5 card evaluator, though I saved a lot of memory
        # space using a hash table and condensing some of the calculations.
        # """
        # if flush
        if cards[0] & cards[1] & cards[2] & cards[3] & cards[4] & 0xF000:
            handOR = (cards[0] | cards[1] | cards[2] | cards[3] | cards[4]) >> 16
            prime = Card.prime_product_from_rankbits(handOR)
            return self.table.flush_lookup[prime]

        # otherwise
        else:
            prime = Card.prime_product_from_hand(cards)
            return self.table.unsuited_lookup[prime]

    def _six(self, cards: Sequence[int]) -> int:
        # """
        # Performs five_card_eval() on all (6 choose 5) = 6 subsets
        # of 5 cards in the set of 6 to determine the best ranking,
        # and returns this ranking.
        # """
        minimum = LookupTable.MAX_HIGH_CARD

        for combo in itertools.combinations(cards, 5):

            score = self._five(combo)
            if score < minimum:
                minimum = score

        return minimum

    def _seven(self, cards: Sequence[int]) -> int:
        # """
        # Performs five_card_eval() on all (7 choose 5) = 21 subsets
        # of 5 cards in the set of 7 to determine the best ranking,
        # and returns this ranking.
        # """
        minimum = LookupTable.MAX_HIGH_CARD

        for combo in itertools.combinations(cards, 5):

            score = self._five(combo)
            if score < minimum:
                minimum = score

        return minimum

    def get_rank_class(self, hr: int) -> int:
        # """
        # Returns the class of hand given the hand hand_rank
        # returned from evaluate.
        # """
        if hr >= 0 and hr <= LookupTable.MAX_ROYAL_FLUSH:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_ROYAL_FLUSH]
        elif hr <= LookupTable.MAX_STRAIGHT_FLUSH:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_STRAIGHT_FLUSH]
        elif hr <= LookupTable.MAX_FOUR_OF_A_KIND:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FOUR_OF_A_KIND]
        elif hr <= LookupTable.MAX_FULL_HOUSE:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FULL_HOUSE]
        elif hr <= LookupTable.MAX_FLUSH:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_FLUSH]
        elif hr <= LookupTable.MAX_STRAIGHT:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_STRAIGHT]
        elif hr <= LookupTable.MAX_THREE_OF_A_KIND:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_THREE_OF_A_KIND]
        elif hr <= LookupTable.MAX_TWO_PAIR:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_TWO_PAIR]
        elif hr <= LookupTable.MAX_PAIR:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_PAIR]
        elif hr <= LookupTable.MAX_HIGH_CARD:
            return LookupTable.MAX_TO_RANK_CLASS[LookupTable.MAX_HIGH_CARD]
        else:
            raise Exception("Inavlid hand rank, cannot return rank class")

    def class_to_string(self, class_int: int) -> str:
        # """
        # Converts the integer class hand score into a human-readable string.
        # """
        return LookupTable.RANK_CLASS_TO_STRING[class_int]

    def get_five_card_rank_percentage(self, hand_rank: int) -> float:
        # """
        # Scales the hand rank score to the [0.0, 1.0] range.
        # """
        return float(hand_rank) / float(LookupTable.MAX_HIGH_CARD)

    #Evaluate flop stage and winrate percentage
    def flop_evaluate(self, board: list[int], players: list[list]) -> None:

      line_lenght = 10
      stage = "FLOP"
      line = "=" * line_lenght

      best_rank = 7463  # rank one worse than worst hand
      winners = []
      print("{} {} {}".format(line,stage,line))
      for player in players:
        rank = self.evaluate(player.cards,board)
        rank_class = self.get_rank_class(rank)
        player.card_class = self.class_to_string(rank_class)
        player.winrate = 1 - self.get_five_card_rank_percentage(rank)
        print("{} hand = {}, winrate = {}%".format(player.name, player.card_class, player.winrate))
        if rank == best_rank:
            winners.append(player)
            best_rank = rank
        elif rank < best_rank:
            winners.insert(0, player)
            best_rank = rank
      return winners

    def turn_evaluate(self, board: list[int], players: list[list]) -> None:

      line_lenght = 10
      stage = "TURN"
      line = "=" * line_lenght

      print("{} {} {}".format(line,stage,line))
      best_rank = 7463  # rank one worse than worst hand
      winners = []
      for player in players:
        rank = self.evaluate(player.cards,board)
        rank_class = self.get_rank_class(rank)
        player.card_class = self.class_to_string(rank_class)
        player.winrate = 1 - self.get_five_card_rank_percentage(rank)
        print("{} hand = {}, winrate = {}%".format(player.name, player.card_class, player.winrate))
        if rank == best_rank:
            winners.append(player)
            best_rank = rank
        elif rank < best_rank:
            winners.insert(0, player)
            best_rank = rank
      return winners

    def hand_summary(self, board: list[int], players: list[list]) -> list[str]:
        # """
        # Gives a sumamry of the hand with ranks as time proceeds.

        # Requires that the board is in chronological order for the
        # analysis to make sense.
        # """

        line_length = 10
        stages = "RIVER"
        line = "=" * line_length
        print("{} {} {}".format(line,stages,line))


        best_rank = 7463  # rank one worse than worst hand
        winners = []
        for player in players:
          rank = self.evaluate(player.cards,board)
          rank_class = self.get_rank_class(rank)
          player.card_class = self.class_to_string(rank_class)
          player.winrate = 1 - self.get_five_card_rank_percentage(rank)
          print("{} hand = {}, winrate = {}%".format(player.name, player.card_class, player.winrate))
          if rank == best_rank:
            winners.append(player)
            best_rank = rank
          elif rank < best_rank:
            winners.insert(0, player)
            best_rank = rank
          # if len(winners) == 1:
          #   print("Player {} hand is currently winning.\n".format(winners[0] + 1))
          # else:
          #   print("Players {} are tied for the lead.\n".format([x + 1 for x in winners]))
        hand_result = self.class_to_string(self.get_rank_class(self.evaluate(winners[0].cards, board)))
        return winners



class PLOEvaluator(Evaluator):

    HAND_LENGTH = 4

    def evaluate(self, hand: list[int], board: list[int]) -> int:
        minimum = LookupTable.MAX_HIGH_CARD

        for hand_combo in itertools.combinations(hand, 2):
            for board_combo in itertools.combinations(board, 3):
                score = Evaluator._five(self, list(board_combo) + list(hand_combo))
                if score < minimum:
                    minimum = score

        return minimum

"""# game"""

pip install -U peaceful-pie

import time
import torch
import numpy as np
from collections import deque

from Rl_poker.networks.dqnagent import *
from Rl_poker.utils.replay_buffer import *
from Rl_poker.utils.rewardfc import *

!unzip '/content/Rl_poker.zip'

#========================================================================================Player========================================================================================#

class Player:
  def __init__(self, name):
    # Game initial variable
    self.name = name
    self.cards = []
    self.chips = 100
    self.stake = 0
    self.stake_gap = 0
    self.hole = 0
    self.fold = False
    self.ready = False
    self.all_in = False
    self.list_of_special_attributes = []
    self.card_class = ""
    self.winrate = 0
    self.turn = 0
    self.rank = 0
    # For past action()
    ## self.past_action = deque([0] * 30, maxlen=30) # Initialize 'past_action' as a deque with a maximum length of 30
    # For part turn()
    ## self.turns = deque([0] * 30, maxlen=30) # Initialize 'turns' as a deque with a maximum length of 30
    #For to_index()
    ## self.ranks = '23456789TJQKA'
    ## self.suits = '♣♦♥♠'
    ## self.dict_cards = {card: val + 1 for val, card in enumerate(self.generate_card_strings())} # Create a dictionary to map card strings to numerical values
    #For get_agent_card()
    # self.agent_card = []
    # self.agent_hand = []

#-----------------------------------card to index-----------------------------------#

  # def generate_card_strings(self):
  #     # Generate a list of all possible card strings
  #     return [rank + suit for rank in self.ranks for suit in self.suits]


  # def to_index(self, card_in):
  #     # Convert the card_in object to a pretty string representation
  #     card = Card.int_to_pretty_str(card_in)

  #     # Extract the rank and suit from the pretty string representation
  #     rank_str = card[0]
  #     suit_str = card[1]

  #     # Create a card string by combining the rank and suit
  #     card_str = rank_str + suit_str

  #     # Retrieve the numerical value (index) for the card string from the precomputed dictionary
  #     carvec = self.dict_cards[card_str]

  #     # Return the index for the given card
  #     return carvec

#-----------------------------------card to index-----------------------------------#

#-----------------------------------print info-----------------------------------#
  def print_round_info(self, pot: int, cards:list[int]):
    print("\n")
    # Player-specific information
    print(f"Name: {self.name}")
    print(f"Cards: {Card.ints_to_pretty_str(self.cards)}") # Display the player's cards
    print(f"Chips: {self.chips}")
    print(f"Special Attributes: {self.list_of_special_attributes}")
    # Display special states (folded or all-in)
    if self.fold:
      print(f"Folded")
    if self.all_in:
      print(f"All-in")
    # Stake-related information
    print(f"Stake: {self.stake}") # Current stake
    print(f"Stake-gap: {self.stake_gap}") # Gap between current stake and previous stake

    print("\n")
    # Pot and community card information
    print(f"Pot: {pot}") # Current pot value
    print(f"Community cards: {Card.ints_to_pretty_str(cards)}") # Display community cards
    print("\n")
#-----------------------------------print info-----------------------------------#

  def clear_player(self):
    self.cards.clear()
    self.stake = 0
    self.stake_gap = 0
    self.ready = False
    self.all_in = False
    self.fold = False
    self.list_of_special_attributes.clear()
    self.win = False
    self.card_class = ""
    self.winrate = 0
    self.turn = 0
    ## self.agent_card = []
    ## self.agent_hand = []
    ## self.turns = [0] * 30
    ## self.past_action = deque(maxlen=30)

#-----------------------------------past action-----------------------------------#

  # def get_past(self, act : str, turn):
  #   # List of valid action choices
  #   action_choices = ['call', 'bet', 'raise', 'fold', 'all_in', 'check']
  #   # Get the index of the provided action 'act' in the 'action_choices' list
  #   index = action_choices.index(act)
  #   # Append the current action index to 'past_action'
  #   self.past_action[turn] = index + 1
  #   # Return the 'past_action' deque
  #   return list(self.past_action)

#-----------------------------------past action-----------------------------------#

#-----------------------------------past turn-----------------------------------#

  # def past_turn(self, turn : int):
  #   if turn <= 30:
  #     self.turns[turn] = 1
  #   else:
  #     self.turns.append(1)
  #   return self.turns

#-----------------------------------past turn-----------------------------------#

#-----------------------------------count agnet turn-----------------------------------#

  # def count_agent_turn(self) -> int:
  #   # Count the occurrences of the value 1 in the 'self.turns1' list.
  #   c = sum(1 for turn in self.turns if turn == 1)
  #   # Return the count.
  #   return c

#-----------------------------------count agnet turn-----------------------------------#

#-----------------------------------get agent card-----------------------------------#

  # def get_agent_cards(self, cards):
  #   if len(cards) != 1:
  #     self.agent_card = [self.to_index(card) for card in cards]
  #   else:
  #     self.agent_card = cards

  #   # Ensure 'agent_card' has exactly 2 elements and pad with zeros if needed
  #   self.agent_card += [0] * (2 - len(self.agent_card))

  #   # Assign the first two elements to 'agent_hands'
  #   self.agent_hand = self.agent_card[:2]

  #   # Pad 'agent_card' to a total length of 8
  #   self.agent_cards = self.agent_card + [0] * (8 - len(self.agent_card))

#-----------------------------------get agent card-----------------------------------#

#-----------------------------------agent turn-----------------------------------#

  # def agent_turn(self, avc : list[int] ,poted : list[float]):
  #   return (torch.tensor([np.array(self.agent_cards, dtype=int)]).int(),
  #           torch.tensor([np.array(self.past_action, dtype=int)]).int() ,
  #           torch.tensor([np.array(self.turns, dtype=int)]).int(),
  #           torch.tensor([np.array([self.winrate], dtype=float)]).float(),
  #           torch.tensor(np.array([self.hole], dtype=int)).int(),
  #           torch.tensor([np.array(poted, dtype=float)]).float(),
  #           avc)

#-----------------------------------agent turn-----------------------------------#

  def __repr__(self):
     name = self.name
     return name

#========================================================================================Player========================================================================================#
class Pokergame:
  def __init__(self):
    # self.agent = Q_Net()
    self.deck = Deck()
    self.game_over = False
    self.possible_responses = []
    self.round_counter = 0
    self.turn_counter = 0
    self.cards = []
    self.pot = 0
    ## self.poted = deque([0]*30,maxlen=30) # Initialize 'poted' as a deque with a maximum length of 30
    self.small_blind = None
    self.big_blind = None
    self.first_actor = None
    self.winners = []
    self.starting_chips = 100
    self.ready_list = []
    self.Player1 = Player('Player1')
    self.Player2 = Player('Player2')
    self.Player3 = Player('Player3')
    self.list_of_players = [self.Player1, self.Player2, self.Player3]
    self.small_blind_amount = 1
    self.big_blind_amount = 2
    self.winner = None
    self.game_counter = 0
    self.highest_stake = 0
    self.fold_list = []
    self.round_ended = False
    self.response = None
    self.fold_out = False
    self.list_of_players_not_out = list(set(self.list_of_players))
    self.number_of_player_not_out = int(len(list(set(self.list_of_players))))

#-----------------------------------attributes-----------------------------------#

  def establish_player_attributes(self):
    # Initialize the address_assignment variable to 0
    address_assignment = 0

    # Move to the next player
    address_assignment += 1
    address_assignment %= len(self.list_of_players_not_out)

    # Assign the 'small blind' attribute to the next player and add it to their special attributes list
    self.small_blind = self.list_of_players_not_out[address_assignment]
    self.small_blind.list_of_special_attributes.append("small blind")

    # Move to the next player
    address_assignment += 1
    address_assignment %= len(self.list_of_players_not_out)

    # Assign the 'big blind' attribute to the next player and add it to their special attributes list
    self.big_blind = self.list_of_players_not_out[address_assignment]
    self.big_blind.list_of_special_attributes.append("big blind")

    # Move to the next player
    address_assignment += 1
    address_assignment %= len(self.list_of_players_not_out)

    # Assign the 'first actor' attribute to the next player and add it to their special attributes list
    self.first_actor = self.list_of_players_not_out[address_assignment]
    self.first_actor.list_of_special_attributes.append("first actor")

    # Move the assigned players to the end of the list to maintain attribute order
    self.list_of_players_not_out.append(self.list_of_players_not_out.pop(0))

#-----------------------------------attributes-----------------------------------#

#-----------------------------------dealer-----------------------------------#

  def dealer(self):
    # Depending on the value of 'round_counter', the dealer performs different actions.
    EV = Evaluator()
    # In the first round, the dealer gives two cards to each player who is not out and marks them as hole cards.
    match self.round_counter:
      case 1:
        for player in self.list_of_players_not_out:
          player.cards = self.deck.draw(2)
          player.print_round_info(self.pot, self.cards)
        self.act_one()

    # In the second round, the dealer draws three community cards and adds them to the 'cards' list.
      case 2:
        ranks = []
        self.cards = self.deck.draw(3)
        for player in self.list_of_players_not_out:
          player.print_round_info(self.pot, self.cards)
        ranks = EV.flop_evaluate(self.cards,self.list_of_players_not_out)

    # For 3-4 round , the dealer draws one additional community card and appends it to the 'cards' list.
      case 3:
        ranks = []
        self.cards.append(self.deck.draw(1))
        for player in self.list_of_players_not_out:
          player.print_round_info(self.pot, self.cards)
        ranks = EV.flop_evaluate(self.cards,self.list_of_players_not_out)

      case 4:
        ranks = []
        self.cards.append(self.deck.draw(1))
        for player in self.list_of_players_not_out:
          player.print_round_info(self.pot, self.cards)
        ranks = EV.flop_evaluate(self.cards,self.list_of_players_not_out)

#-----------------------------------dealer-----------------------------------#

#-----------------------------------clear board-----------------------------------#
  #Clear board
  def clear_board(self):
    self.possible_responses.clear()
    self.cards.clear()
    self.deck = Deck()
    self.pot = 0
    self.winners.clear()
    self.action_counter = 0
    self.highest_stake = 0
    self.fold_list.clear()
    self.fold_out = False
    self.round_ended = False
    self.turns = []
    # self.poted = []
    # self.poted = deque([0]*30,maxlen=30)
    self.list_of_players_not_out = list(set(self.list_of_players)).copy()
    for player in self.list_of_players_not_out:
      if player.chips <= 0:
        self.list_of_players_not_out.pop(self.list_of_players_not_out.index(player))

#-----------------------------------clear board-----------------------------------#

#-----------------------------------end game-----------------------------------#

  def end_round(self):
    # Remove players with no chips or who have folded from the list
    self.list_of_players_not_out = [player for player in self.list_of_players_not_out if player.chips > 0 and not player.fold]

    if len(self.list_of_players_not_out) == 1:
        # Game is over with one player left
        self.game_over = True
        winning_player = self.list_of_players_not_out[0]
        print(f"Game is over: {winning_player} wins with {winning_player.card_class}!")
        quit()

    # Distribute the pot to the winner(s)
    self.winners[0].chips += self.pot
    print("{} win with: {}".format(self.winners[0].name, self.winners[0].card_class))

    new_round = input("Start a new round? (yes/no): ")

    if new_round.lower() == "yes":
        print("\n\n\t\t\t\t--ROUND OVER--")
        print("\n\n\t\t\t--STARTING NEW ROUND--\n")
        self.game_counter += 1
        time.sleep(0.3)
        self.clear_board()
    else:
        quit()

#-----------------------------------end game-----------------------------------#

#-----------------------------------answer-----------------------------------#

##-----------------------------------determine possible response-----------------------------------##
  def determine_possible_responses(self, player):
    # Create a list of possible responses based on the player's situation
    self.possible_responses.clear()

    if player.stake_gap > 0:
        self.possible_responses.append("fold")

    if player.stake_gap == player.chips:
        self.possible_responses.append("all_in")

    if player.stake_gap > player.chips:
        self.possible_responses.append("all_in")

    if player.stake_gap < player.chips:
        possible_actions = ["call", "all_in", "raise"]
        self.possible_responses.extend(action for action in possible_actions if action not in self.possible_responses)

    if player.stake_gap == 0:
        possible_actions = ["check", "bet", "fold", "all_in"]
        self.possible_responses.extend(action for action in possible_actions if action not in self.possible_responses)

##-----------------------------------display player turn info-----------------------------------##

  def display_player_turn_info(self, player):
    # Display information about the player's turn
    line = "=" * 10
    pn = player.name + "'s turn"
    print("{} {} {}".format(line, pn, line))
    print(f"Highest stake: {self.highest_stake}")
    print(f"Put in at least {player.stake_gap} to stay in.")
    print("Don't have that much? You'll have to go all-in!")
    print(f"Chips available: {player.chips}")

##-----------------------------------player_turn_ended----------------------------------##

  def player_turn_ended(self, player):
    # Check if the player's turn has ended based on their response
    return player.all_in or player.fold or self.fold_out

##-----------------------------------all_in----------------------------------##

  def handle_all_in(self, player):
      # Handle the player going all-in
      self.turn_counter += 1
      # player.get_past("all_in", self.turn_counter)
      # player.past_turn(self.turn_counter)
      print(f"{player.name} is all-in!")
      player.stake += player.chips
      self.pot += player.chips
      # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
      self.get_poted(self.pot)
      player.stake_gap -= player.chips
      player.chips = 0
      player.all_in = True

      if player.stake_gap > player.chips:
          return True

      if player.stake_gap == player.chips:
          player.stake += player.stake_gap
          self.pot += player.stake_gap
          # self.get_poted(self.pot)
          player.stake_gap = 0
          return True

      if player.stake_gap == 0:
          player.stake_gap = 0
          self.highest_stake = player.stake
          self.ready_list.clear()
          return True

      if player.stake_gap < player.chips:
          player.stake_gap = 0
          player.stake += player.chips
          self.pot += player.chips
          # self.get_poted(self.pot)
          player.chips = 0
          self.highest_stake = player.stake
          self.ready_list.clear()
          return True
      return True

##-----------------------------------fold----------------------------------##

  def handle_fold(self, player):
    # Handle the player folding
    self.turn_counter += 1
    # player.get_past("fold", self.turn_counter)
    # player.past_turn(self.turn_counter)
    # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
    player.fold = True
    self.fold_list.append(player)

    if len(self.fold_list) == (len(self.list_of_players_not_out)):
        for remaining_player in self.list_of_players_not_out:
            if remaining_player not in self.fold_list:
                self.fold_out = True
                print(f"{remaining_player.name} wins!")
                self.winners.append(remaining_player)
                self.end_round = True
                return True

        for winning_player in self.winners:
            winning_player.win = True
            self.round_ended = True
            return True
    self.list_of_players_not_out.remove(player)
    return True

##-----------------------------------call----------------------------------##

  def handle_call(self, player):
    # Handle the player's call
    self.turn_counter += 1
    # player.get_past("call", self.turn_counter)
    # player.past_turn(self.turn_counter)
    player.stake += player.stake_gap
    self.pot += player.stake_gap
    # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
    # self.get_poted(self.pot)
    player.chips -= player.stake_gap
    player.stake_gap = 0
    return True

##-----------------------------------check----------------------------------##
  def handle_check(self, player):
    # Handle the player's check
    self.turn_counter += 1
    # player.get_past("check", self.turn_counter)
    # player.past_turn(self.turn_counter)
    player.stake_gap = 0
    # self.get_poted(0)
    # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
    return True

##-----------------------------------bet or raise----------------------------------##

  def handle_bet_or_raise(self, player):
    # Handle the player's bet or raise
    # if self.response == "bet":
        # player.get_past("bet", self.turn_counter)
    # if self.response == "raise":
        # player.get_past("raise", self.turn_counter)
    self.turn_counter += 1
    # player.past_turn(self.turn_counter)
    bet = int(input(f"How much would {player.name} like to raise? ({player.chips} available)\n->"))

    if bet > player.chips or bet <= 0:
        print("Invalid response")
        return  # Return to allow the player to try again

    if player.stake_gap == 0:
        player.stake += bet
        self.pot += bet
        # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
        # self.get_poted(self.pot)
        player.chips -= bet
        self.highest_stake = player.stake
        self.ready_list.clear()
        player.stake_gap = 0
        return True

        if bet == player.chips:
            print(f"{player.name} is all-in!")
            player.all_in = True
            return True
    if player.stake_gap < player.chips:
        player.stake += player.stake_gap
        self.pot += player.stake_gap
        player.chips -= player.stake_gap
        player.stake_gap = 0
        player.stake += bet
        self.pot += bet
        # reward_compute(self.response, player.rank, self.pot, False, 0, player.winrate, player.count_agent_turn())
        # self.get_poted(self.pot)
        player.chips -= bet
        self.highest_stake = player.stake
        self.ready_list.clear()
        player.stake_gap = 0
        return True

        if bet == player.chips:
            print(f"{player.name} is all-in!")
            player.all_in = True
            return True
    return True

##-----------------------------------answer----------------------------------##
  def answer(self, player):
    player.stake_gap = self.highest_stake - player.stake

    # Check if the player's turn should be skipped based on certain conditions
    if player.all_in or player.fold or self.fold_out:
        return True

    if player.chips <= 0:
        print(f"{player.name} is all in!")
        player.all_in = True

    # Display the player's turn information
    # self.display_player_turn_info(player)

    # Create a list of possible responses based on the player's situation
    self.determine_possible_responses(player)
    # Perform the agent's turn to make a decision
    # action_choices = ['call', 'bet', 'raise', 'fold', 'all_in', 'check']
    # a, b, c, d, e, f, g = None, None, None, None, None, None, None
    # act = None
    self.response = None
    self.display_player_turn_info(player)
    print(self.possible_responses)

    # a,b,c,d,e,f,g = player.agent_turn(self.possible_responses, self.poted)
    # act = self.agent.get_action(a,b,c,d,e,f,g)


    # Continue processing the player's turn based on their response
    while True:
        self.response = input("Enter your input: ")
        if self.response not in self.possible_responses:
            print("Invalid response")
            continue

        if self.response == "all_in":
            self.handle_all_in(player)
            return True
        elif self.response == "fold":
            self.handle_fold(player)
            return True
        elif self.response == "call":
            self.handle_call(player)
            return True
        elif self.response == "check":
            self.handle_check(player)
            return True
        elif self.response in ["bet", "raise"]:
            self.handle_bet_or_raise(player)
            return True

        # Check if the player's turn has ended based on their response
        if self.player_turn_ended(player):
            return True
    return True
    # else:
    #   while True:
    #     print("{} {} {}".format(line,pn,line))
    #     print(self.possible_responses)
    #     self.response = input("Enter your action: ")
    #     if self.response not in self.possible_responses:
    #       print("Invalid response")
    #       continue
    #     if self.response == "all_in":
    #       self.get_past("all_in")
    #       print(f"{player.name} is all-in!")
    #       player.stake += player.chips
    #       self.pot += player.chips
    #       self.get_poted(self.pot)
    #       player.stake_gap -= player.chips
    #       player.chips = 0
    #       player.all_in = True
    #       if player.stake_gap > player.chips:
    #         return True
    #       if player.stake_gap == player.chips:
    #         player.stake += player.stake_gap
    #         self.pot += player.stake_gap
    #         self.get_poted(self.pot)
    #         player.stake_gap = 0
    #       if player.stake_gap == 0:
    #         player.stake_gap = 0
    #         self.highest_stake = player.stake
    #         self.ready_list.clear()
    #       if player.stake_gap < player.chips:
    #         player.stake_gap = 0
    #         player.stake += player.chips
    #         self.pot += player.chips
    #         self.get_poted(self.pot)
    #         player.chips = 0
    #         self.highest_stake = player.stake
    #         self.ready_list.clear()
    #       return True
    #     if self.response == "fold":
    #       self.get_past("fold")
    #       player.fold = True
    #       # self.list_of_players_not_out.pop(self.list_of_players_not_out.index(player))
    #       self.fold_list.append(player)
    #       if len(self.fold_list) == (len(self.list_of_players_not_out) - 1):
    #         for player in self.list_of_players_not_out:
    #           if player not in self.fold_list:
    #             self.fold_out = True
    #             print(f"{player} wins!")
    #             self.winners.append(player)
    #             for player in self.winners:
    #               player.win = True
    #               self.round_ended = True
    #       return True
    #     if self.response == "call":
    #       self.get_past("call")
    #       player.stake += player.stake_gap
    #       self.pot += player.stake_gap
    #       self.get_poted(self.pot)
    #       player.chips -= player.stake_gap
    #       player.stake_gap = 0
    #       return True
    #     if self.response == "check":
    #       self.get_past("check")
    #       player.stake_gap = 0
    #       self.get_poted(0)
    #       return True
    #     if self.response == "bet" or "raise":
    #       if self.response == " bet":
    #         self.get_past("bet")
    #       if self.response == " raise":
    #         self.get_past("raise")
    #       self.need_raise_info = True
    #       bet = int(input(f"How much would {player.name} like to raise? ({player.chips} available)\n->"))
    #       if bet > player.chips or bet <= 0:
    #         print("Invalid response")
    #       if player.stake_gap == 0:
    #         player.stake += bet
    #         self.pot += bet
    #         self.get_poted(self.pot)
    #         player.chips -= bet
    #         self.highest_stake = player.stake
    #         self.ready_list.clear()
    #         player.stake_gap = 0
    #         if bet == player.chips:
    #           print(f"{player.name} is all-in!")
    #           player.all_in = True
    #           return True
    #         return True
    #       if player.stake_gap < player.chips:
    #         player.stake += player.stake_gap
    #         self.pot += player.stake_gap
    #         player.chips -= player.stake_gap
    #         player.stake_gap = 0
    #         player.stake += bet
    #         self.pot += bet
    #         self.get_poted(self.pot)
    #         player.chips -= bet
    #         self.highest_stake = player.stake
    #         self.ready_list.clear()
    #         player.stake_gap = 0
    #         if bet == player.chips:
    #           print(f"{player.name} is all-in!")
    #           player.all_in = True
    #         return True
    #       return True
    print("Invalid Response")

#-----------------------------------answer-----------------------------------#

#-----------------------------------ask player-----------------------------------#

  def ask_players(self):
    # Clear the list of ready players and determine the starting index
    self.ready_list.clear()
    starting_index = self.list_of_players_not_out.index(self.first_actor)

    # Mark all players as not ready
    for player in self.list_of_players_not_out:
        player.ready = False

    while True:
        # Determine the current acting player
        self.acting_player = self.list_of_players_not_out[starting_index]

        # Ask the acting player for their response and check if they are ready
        player_ready = self.answer(self.list_of_players_not_out[starting_index])

        # Move to the next player in the list
        starting_index += 1
        starting_index %= len(self.list_of_players_not_out)

        # Track the ready status of players
        if player_ready == True:
            self.ready_list.append("ready")
        len(self.ready_list)
        # If all players are ready, exit the loop
        if len(self.ready_list) == len(self.list_of_players_not_out):
            break

#-----------------------------------ask player-----------------------------------#

#-----------------------------------act one-----------------------------------#

  def act_one(self):
    # Helper function to perform blind actions for a player
    def perform_blind(player, blind_amount):
        if blind_amount > player.chips:
            # Player goes all-in if they don't have enough chips for the blind
            player.stake += player.chipsS
            self.highest_stake = player.chips
            self.pot += player.chips
            # self.get_poted(self.pot)
            player.chips = 0
            print(f"{player.name} is all-in!")
            player.all_in = True
        else:
            # Deduct blind amount from player's chips and update stakes and pot
            player.chips -= blind_amount
            player.stake += blind_amount
            self.highest_stake = blind_amount
            self.pot += blind_amount
            # self.get_poted(self.pot)

    # Perform blinds for the small blind and big blind players
    perform_blind(self.small_blind, self.small_blind_amount)
    perform_blind(self.big_blind, self.big_blind_amount)

    # Proceed to the next phase by asking other players for their actions
    self.ask_players()
    print('......................')

#-----------------------------------act one-----------------------------------#

#-----------------------------------get poted-----------------------------------#

  def get_poted(self, pot):
    # Append the 'pot' to the 'poted' list
    if self.turn_counter <= 30:
      self.poted[self.turn_counter] = pot
    else:
      self.poted.append(pot)
    return self.poted

#-----------------------------------get poted-----------------------------------#

#-----------------------------------get in rank-----------------------------------#

  def get_in_ranks(self, ranks: list, player) -> int:
    for i in range(len(ranks)):
      if ranks[i].name == player.name:
        player.rank = i

#-----------------------------------get in rank-----------------------------------#

#-----------------------------------play----------------------------------#

  def play(self):
    # Create an instance of the Evaluator class
    EV = Evaluator()
    # Initialize player attributes
    self.establish_player_attributes()

    # Iterate through 4 rounds
    for round_step in range(4):
      self.round_counter += 1
      # If the round is not ended, perform the dealer action
      if not self.round_ended:
        self.dealer()
        print('......................')
      # If the round is not ended, ask the player for their action
      if not self.round_ended and self.round_counter != 1:
        self.ask_players()

    # If there are 5 cards and at least one player is still in the game
    if len(self.cards) == 5 and len(self.list_of_players_not_out):
      # Calculate hand summaries and determine the winners
      self.winners = EV.hand_summary(self.cards,self.list_of_players_not_out)
    # Iterate through players who are still in the game
    # for player in self.list_of_players_not_out:
      # Update each player's rank based on the winners
      # self.get_in_ranks(self.winners, player)
      # Compute rewards for the agent
      # reward_compute(self.response, player.rank, self.pot, True, player.chips - 100, player.winrate, player.count_agent_turn())
      # print()
    # Mark the round as ended
    self.round_ended = True
    self.end_round()

  def run_game_data(self):
    # Continuously run the game
    while True:
      self.play()

#-----------------------------------play-----------------------------------#

pgg = Pokergame()

pgg.run_game_data()

"""ca# ai

"""

import multiprocessing
d = Deck()
def to_vector(card_in):
  ranks = '23456789TJQKA'
  suits = '♣♦♥♠'
  dict_rank = {card:val + 1 for val,card in enumerate(ranks)}
  dict_suit = {suit:val + 1 for val,suit in enumerate(suits)}
  rank_str = Card.int_to_pretty_str(card_in)[0]
  suit_str = Card.int_to_pretty_str(card_in)[1]
  card_str = rank_str + suit_str
  rank = dict_rank[rank_str]
  suit = dict_suit[suit_str]
  list_cards = []
  for i in ranks:
    for j in suits:
      list_cards.append(i + j)
  dict_cards = {card:val +1 for val,card in enumerate(list_cards)}
  carvec = dict_cards[card_str]
  return [rank,suit,carvec]

cards_to_process = d.draw(52) # Example list of cards to process
num_processes = multiprocessing.cpu_count()  # Get the number of CPU cores

# Create a multiprocessing Pool to process cards concurrently
with multiprocessing.Pool(processes=num_processes) as pool:
  results = pool.map(to_vector, cards_to_process)

# Process the results if needed
for i,result in enumerate(results):
  print("{}: {}".format(i + 1,result))